<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Tag Image: {{ image_name }}</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body class="editor-body">

    <div id="main-container">
        <div id="image-area">
            <div id="img-wrapper">
                <img id="target-image" src="{{ url_for('images', filename=image_name) }}" alt="Target Image">
                <svg id="blur-overlay"></svg>
                <div id="overlay"></div>
            </div>
        </div>
        <div id="sidebar">
            <div id="sidebar-header">
                <div>
                    <a href="/" id="back-link">← Back to Gallery</a>
                </div>
                <div id="header-top">
                    <div class="mode-switch">
                        <button id="mode-tag-btn" class="active" onclick="setMode('tag')">Tag</button>
                        <button id="mode-blur-btn" onclick="setMode('blur')">Blur</button>
                    </div>
                </div>
                <div id="blur-warning"
                    style="display:none; color: #ff6b6b; font-size: 0.8rem; margin-top: 5px; background: rgba(255, 0, 0, 0.1); padding: 5px; border-radius: 4px;">
                    ⚠️ Destructive: Changes are permanent. Make a backup!
                </div>
                <div id="header-actions">
                    <button id="save-btn" onclick="saveTags()">Save Tags</button>
                    <button id="burn-btn" onclick="burnBlurs()" style="display:none; background: #e63946;">Burn
                        Blurs</button>
                </div>
            </div>
            <div id="tags-list">
                <div class="empty-state">Draw a box on the image to add a tag.</div>
            </div>
        </div>
    </div>

    <script>
        // State
        // Initialize tags from server-side variable
        let tags = {{ tags | tojson }};
        let blurs = []; // State for blurs {id, points: [{x,y}...], text: ''}
        let currentMode = 'tag'; // 'tag' or 'blur'

        let isDrawing = false;

        let startX, startY;
        let currentBoxId = null; // Used for both tags and blurs creation
        let draggedBox = null;   // For Tag dragging
        let draggedBlur = null;  // For Blur overall dragging (optional) or creation
        let draggedHandle = null; // {blurId, pointIndex}

        let resizeHandle = null; // 'nw', 'ne', etc. (Tags only)

        // DOM Elements
        const overlay = document.getElementById('overlay');
        const blurOverlay = document.getElementById('blur-overlay');
        const tagsListEl = document.getElementById('tags-list');
        const imgWrapper = document.getElementById('img-wrapper');
        const targetImage = document.getElementById('target-image');

        // Mode Switching
        function setMode(mode) {
            currentMode = mode;
            document.getElementById('mode-tag-btn').className = mode === 'tag' ? 'active' : '';
            document.getElementById('mode-blur-btn').className = mode === 'blur' ? 'active' : '';

            // Toggle visibility
            if (mode === 'tag') {
                overlay.style.pointerEvents = 'auto';
                // blurOverlay.style.pointerEvents = 'none';
                document.getElementById('save-btn').style.display = 'inline-block';
                document.getElementById('burn-btn').style.display = 'none';
                document.getElementById('blur-warning').style.display = 'none';
                renderTagsList(); // Show tags in sidebar
            } else {
                // blurOverlay.style.pointerEvents = 'auto';
                // overlay.style.pointerEvents = 'none'; // We might still need overlay for capturing clicks?
                // Actually, let's keep overlay capturing events, but logic differs
                document.getElementById('save-btn').style.display = 'none';
                document.getElementById('burn-btn').style.display = 'inline-block';
                document.getElementById('blur-warning').style.display = 'block';
                renderBlurList(); // Show blurs in sidebar
            }
            deselectAll();
        }

        // Utils
        function generateId() {
            return 'item_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function toPercent(val, total) {
            return (val / total) * 100;
        }

        function toPx(percent, total) {
            return (percent / 100) * total;
        }

        // --- Overlay Event Delegation ---
        overlay.addEventListener('mousedown', (e) => {
            if (currentMode === 'tag') {
                handleTagMouseDown(e);
            } else {
                handleBlurMouseDown(e);
            }
        });

        // Split logic functions
        function handleTagMouseDown(e) {
            if (e.target.classList.contains('resize-handle')) {
                // Handled in local resize logic if attached, but here we used global flow before.
                // It was: e.stopPropagation in the element creation.
                return;
            }

            if (e.target.classList.contains('hotspot-box')) {
                const id = e.target.dataset.id;
                selectTag(id);
                draggedBox = tags.find(t => t.id === id);
                if (!draggedBox) return;

                const rect = overlay.getBoundingClientRect();
                startX = e.clientX - rect.left;
                startY = e.clientY - rect.top;

                draggedBox._dragStartMouseX = startX;
                draggedBox._dragStartMouseY = startY;
                draggedBox._initialX = draggedBox.x;
                draggedBox._initialY = draggedBox.y;

                document.addEventListener('mousemove', onDragMove);
                document.addEventListener('mouseup', onDragEnd);
                return;
            }

            // Start Drawing Tag
            isDrawing = true;
            const rect = overlay.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;

            currentBoxId = generateId();
            const box = document.createElement('div');
            box.classList.add('hotspot-box');
            box.dataset.id = currentBoxId;
            box.style.left = startX + 'px';
            box.style.top = startY + 'px';
            box.style.width = '0px';
            box.style.height = '0px';
            overlay.appendChild(box);

            document.addEventListener('mousemove', onDrawMove);
            document.addEventListener('mouseup', onDrawEnd);
        }

        function handleBlurMouseDown(e) {
            // Check for handle click
            if (e.target.classList.contains('quad-handle')) {
                const blurId = e.target.dataset.blurId;
                const pIdx = parseInt(e.target.dataset.pointIndex);
                draggedHandle = { blurId, pIdx };
                selectBlur(blurId);

                document.addEventListener('mousemove', onBlurHandleDrag);
                document.addEventListener('mouseup', onBlurHandleEnd);
                return;
            }

            // Check if clicking inside a polygon (approximated by checking if SVG element is hit, but overlay covers it)
            // Since overlay covers everything, we can't click the polygon directly unless we forward events or check raycast.
            // For now: assume clicking anywhere else starts drawing a NEW blur.

            isDrawing = true;
            const rect = overlay.getBoundingClientRect();
            startX = e.clientX - rect.left;
            startY = e.clientY - rect.top;

            currentBoxId = generateId();

            // Visual feedback during draw: standard box
            const box = document.createElement('div');
            box.id = 'temp-blur-box';
            box.style.position = 'absolute';
            box.style.border = '2px dashed #e63946';
            box.style.left = startX + 'px';
            box.style.top = startY + 'px';
            box.style.width = '0px';
            box.style.height = '0px';
            overlay.appendChild(box);

            document.addEventListener('mousemove', onDrawBlurMove);
            document.addEventListener('mouseup', onDrawBlurEnd);
        }

        // --- Tag Draw Handlers ---
        function onDrawMove(e) {
            if (!isDrawing) return;
            const rect = overlay.getBoundingClientRect();
            let currentX = e.clientX - rect.left;
            let currentY = e.clientY - rect.top;
            currentX = Math.max(0, Math.min(currentX, rect.width));
            currentY = Math.max(0, Math.min(currentY, rect.height));

            const width = currentX - startX;
            const height = currentY - startY;

            const box = overlay.querySelector(`[data-id="${currentBoxId}"]`);
            if (box) {
                box.style.left = (width < 0 ? currentX : startX) + 'px';
                box.style.top = (height < 0 ? currentY : startY) + 'px';
                box.style.width = Math.abs(width) + 'px';
                box.style.height = Math.abs(height) + 'px';
            }
        }

        function onDrawEnd(e) {
            if (!isDrawing) return;
            isDrawing = false;
            document.removeEventListener('mousemove', onDrawMove);
            document.removeEventListener('mouseup', onDrawEnd);

            const box = overlay.querySelector(`[data-id="${currentBoxId}"]`);
            if (!box) return;

            const rect = overlay.getBoundingClientRect();
            const wPx = parseFloat(box.style.width);
            const hPx = parseFloat(box.style.height);
            const lPx = parseFloat(box.style.left);
            const tPx = parseFloat(box.style.top);

            if (wPx < 5 || hPx < 5) { box.remove(); return; }

            const xPct = toPercent(lPx, rect.width);
            const yPct = toPercent(tPx, rect.height);
            const wPct = toPercent(wPx, rect.width);
            const hPct = toPercent(hPx, rect.height);

            box.style.left = xPct + '%';
            box.style.top = yPct + '%';
            box.style.width = wPct + '%';
            box.style.height = hPct + '%';

            const newTag = { id: currentBoxId, x: xPct, y: yPct, w: wPct, h: hPct, description: "New Tag" };
            tags.push(newTag);
            addHandles(box);
            addLabel(box, newTag.description);
            renderTagsList();
            selectTag(currentBoxId);
        }

        // --- Blur Draw Handlers ---
        function onDrawBlurMove(e) {
            if (!isDrawing) return;
            const rect = overlay.getBoundingClientRect();
            let currentX = e.clientX - rect.left;
            let currentY = e.clientY - rect.top;

            const width = currentX - startX;
            const height = currentY - startY;

            const box = document.getElementById('temp-blur-box');
            if (box) {
                box.style.left = (width < 0 ? currentX : startX) + 'px';
                box.style.top = (height < 0 ? currentY : startY) + 'px';
                box.style.width = Math.abs(width) + 'px';
                box.style.height = Math.abs(height) + 'px';
            }
        }

        function onDrawBlurEnd(e) {
            if (!isDrawing) return;
            isDrawing = false;
            document.removeEventListener('mousemove', onDrawBlurMove);
            document.removeEventListener('mouseup', onDrawBlurEnd);

            const box = document.getElementById('temp-blur-box');
            if (!box) return;

            const rect = overlay.getBoundingClientRect();
            const wPx = parseFloat(box.style.width);
            const hPx = parseFloat(box.style.height);
            const lPx = parseFloat(box.style.left);
            const tPx = parseFloat(box.style.top);
            box.remove();

            if (wPx < 5 || hPx < 5) return;

            // Convert rect to 4 points (percentages)
            const p1 = { x: toPercent(lPx, rect.width), y: toPercent(tPx, rect.height) }; // TL
            const p2 = { x: toPercent(lPx + wPx, rect.width), y: toPercent(tPx, rect.height) }; // TR
            const p3 = { x: toPercent(lPx + wPx, rect.width), y: toPercent(tPx + hPx, rect.height) }; // BR
            const p4 = { x: toPercent(lPx, rect.width), y: toPercent(tPx + hPx, rect.height) }; // BL

            const newBlur = {
                id: currentBoxId,
                points: [p1, p2, p3, p4], // standard order: TL, TR, BR, BL
                text: ""
            };
            blurs.push(newBlur);
            renderBlurs();
            renderBlurList();
            selectBlur(newBlur.id);
        }

        // --- Blur Edit Handlers ---
        function onBlurHandleDrag(e) {
            if (!draggedHandle) return;
            const rect = overlay.getBoundingClientRect();
            let cx = e.clientX - rect.left;
            let cy = e.clientY - rect.top;

            // Clamp
            cx = Math.max(0, Math.min(cx, rect.width));
            cy = Math.max(0, Math.min(cy, rect.height));

            const blur = blurs.find(b => b.id === draggedHandle.blurId);
            if (blur) {
                blur.points[draggedHandle.pIdx] = {
                    x: toPercent(cx, rect.width),
                    y: toPercent(cy, rect.height)
                };
                renderBlurs(); // Re-render SVG and handles
                // Don't re-render list continuously to avoid input focus loss? Actually list doesn't show coords
            }
        }

        function onBlurHandleEnd() {
            draggedHandle = null;
            document.removeEventListener('mousemove', onBlurHandleDrag);
            document.removeEventListener('mouseup', onBlurHandleEnd);
        }


        // --- Tag Drag/Resize Logic ---
        function onDragMove(e) {
            if (!draggedBox) return;
            const rect = overlay.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            const dxPx = currentX - draggedBox._dragStartMouseX;
            const dyPx = currentY - draggedBox._dragStartMouseY;

            const dxPct = toPercent(dxPx, rect.width);
            const dyPct = toPercent(dyPx, rect.height);

            let newX = draggedBox._initialX + dxPct;
            let newY = draggedBox._initialY + dyPct;

            newX = Math.max(0, Math.min(newX, 100 - draggedBox.w));
            newY = Math.max(0, Math.min(newY, 100 - draggedBox.h));

            draggedBox.x = newX;
            draggedBox.y = newY;

            const box = overlay.querySelector(`[data-id="${draggedBox.id}"]`);
            if (box) {
                box.style.left = newX + '%';
                box.style.top = newY + '%';
            }
            updateTagListItem(draggedBox.id);
        }

        function onDragEnd() {
            draggedBox = null;
            document.removeEventListener('mousemove', onDragMove);
            document.removeEventListener('mouseup', onDragEnd);
        }

        function startResize(e, id, pos) {
            const tag = tags.find(t => t.id === id);
            if (!tag) return;

            const box = overlay.querySelector(`[data-id="${id}"]`);
            const rect = overlay.getBoundingClientRect();

            const startMouseX = e.clientX;
            const startMouseY = e.clientY;

            const startW = tag.w;
            const startH = tag.h;
            const startX = tag.x;
            const startY = tag.y;

            function onResizeMove(ev) {
                const dxPx = ev.clientX - startMouseX;
                const dyPx = ev.clientY - startMouseY;
                const dxPct = toPercent(dxPx, rect.width);
                const dyPct = toPercent(dyPx, rect.height);

                let newW = startW, newH = startH, newX = startX, newY = startY;

                if (pos.includes('e')) newW = startW + dxPct;
                if (pos.includes('s')) newH = startH + dyPct;
                if (pos.includes('w')) { newW = startW - dxPct; newX = startX + dxPct; }
                if (pos.includes('n')) { newH = startH - dyPct; newY = startY + dyPct; }

                if (newW > 1 && newH > 1) { // Min size
                    tag.w = newW; tag.h = newH; tag.x = newX; tag.y = newY;
                    box.style.width = newW + '%'; box.style.height = newH + '%';
                    box.style.left = newX + '%'; box.style.top = newY + '%';
                    updateTagListItem(id);
                }
            }

            function onResizeEnd() {
                document.removeEventListener('mousemove', onResizeMove);
                document.removeEventListener('mouseup', onResizeEnd);
            }
            document.addEventListener('mousemove', onResizeMove);
            document.addEventListener('mouseup', onResizeEnd);
        }

        // --- Interaction ---
        function selectTag(id) {
            if (currentMode !== 'tag') return;
            deselectAll();
            const box = overlay.querySelector(`[data-id="${id}"]`);
            if (box) box.classList.add('selected');
            const item = document.getElementById(`list-item-${id}`);
            if (item) {
                item.classList.add('active');
                item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
        }

        function selectBlur(id) {
            if (currentMode !== 'blur') return;
            deselectAll();

            // Highlight SVG poly
            const poly = document.getElementById(`poly-${id}`);
            if (poly) poly.classList.add('selected');

            // Show handles
            const blur = blurs.find(b => b.id === id);
            if (blur) renderBlurHandles(blur);

            // Highlight list item
            const item = document.getElementById(`blur-item-${id}`);
            if (item) {
                item.classList.add('active');
            }
        }

        function deselectAll() {
            // Tags
            document.querySelectorAll('.hotspot-box').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.tag-item').forEach(t => t.classList.remove('active'));

            // Blurs
            document.querySelectorAll('polygon').forEach(p => p.classList.remove('selected'));
            // Remove all handles
            document.querySelectorAll('.quad-handle').forEach(h => h.remove());
        }

        function addHandles(boxElement) {
            const positions = ['nw', 'ne', 'sw', 'se'];
            positions.forEach(pos => {
                const h = document.createElement('div');
                h.classList.add('resize-handle', `rh-${pos}`);
                h.dataset.pos = pos;
                h.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    startResize(e, boxElement.dataset.id, pos);
                });
                boxElement.appendChild(h);
            });
        }

        function addLabel(boxElement, text) {
            let label = boxElement.querySelector('.box-label');
            if (!label) {
                label = document.createElement('div');
                label.className = 'box-label';
                boxElement.appendChild(label);
            }
            label.textContent = text;
        }

        // --- Rendering Blurs ---

        function renderBlurs() {
            // Keep handles if same selection? re-render all to be safe for now
            // But we might be dragging a handle, so we need to move handles efficiently OR just re-render handles for selected only

            // 1. Clear SVG
            blurOverlay.innerHTML = '';

            // 2. Draw polygons
            blurs.forEach(b => {
                const poly = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
                // Points key is x,y in % -> need 0-100 coords for SVG if we set viewBox? 
                // Easier: Set viewBox to "0 0 100 100" preservingAspectRatio="none" on SVG
                // Then points are just x,y

                const pointsStr = b.points.map(p => `${p.x},${p.y}`).join(' ');
                poly.setAttribute('points', pointsStr);
                poly.id = `poly-${b.id}`;
                poly.addEventListener('mousedown', (e) => {
                    // Start selecting this blur
                    // Need to stop prop?
                    // e.stopPropagation(); // Let overlay capture?? No, overlay is ON TOP of SVG usually due to zindex?
                    // Wait, SVG is z-index 5, overlay is 10. CSS says overlay pointer-events auto.
                    // So overlay captures clicks. We can't click SVG directly unless overlay ignores events.
                    // But overlay is needed for drawing new ones.

                    // Solution: We handle selection in handleBlurMouseDown by checking "distance" or just relying solely on Sidebar selection + Creating new ones.
                    // OR: In handleBlurMouseDown, we check if click is inside any existing poly.
                });
                blurOverlay.appendChild(poly);
            });

            // Re-add handles for selected
            const selectedItem = document.querySelector('.tag-item.active');
            // Note: tag-item class reused? No, create new class for blur items
            // Actually checking internal state is better
            // Find 'selected' poly
            // But state isn't stored in DOM. 
            // Let's rely on `draggedHandle` or just check which list item is active if possible, OR just re-render handles if we know which is selected.
            // We'll pass logic to `renderBlurHandles` called by `selectBlur` locally.
            // But if we are Dragging, we need updates.

            if (draggedHandle) {
                const blur = blurs.find(b => b.id === draggedHandle.blurId);
                if (blur) renderBlurHandles(blur);
            }
        }

        // Ensure SVG scales correctly
        blurOverlay.setAttribute('viewBox', '0 0 100 100');
        blurOverlay.setAttribute('preserveAspectRatio', 'none');

        function renderBlurHandles(blur) {
            // Remove existing handles
            document.querySelectorAll('.quad-handle').forEach(h => h.remove());

            blur.points.forEach((p, idx) => {
                const h = document.createElement('div');
                h.classList.add('quad-handle');
                h.dataset.blurId = blur.id;
                h.dataset.pointIndex = idx;
                h.style.left = p.x + '%';
                h.style.top = p.y + '%';
                h.style.display = 'block';
                overlay.appendChild(h); // Append to OVERLAY so it's on top and clickable
            });
        }

        // --- Lists Rendering ---

        function updateTagListItem(id) {
            const tag = tags.find(t => t.id === id);
            if (!tag) return;
            const coordSpan = document.querySelector(`#list-item-${id} .tag-coords`);
            if (coordSpan) {
                coordSpan.innerText = `x:${tag.x.toFixed(2)}%, y:${tag.y.toFixed(2)}%`;
            }
        }

        function renderTagsList() {
            tagsListEl.innerHTML = '';
            if (tags.length === 0) {
                tagsListEl.innerHTML = '<div class="empty-state">Draw a box on the image to add a tag.</div>';
                return;
            }
            tags.forEach(tag => {
                const item = document.createElement('div');
                item.className = 'tag-item';
                item.id = `list-item-${tag.id}`;
                item.innerHTML = `
                <div class="tag-header">
                    <span class="tag-coords">x:${tag.x.toFixed(2)}%, y:${tag.y.toFixed(2)}%</span>
                    <button class="delete-btn" onclick="deleteTag('${tag.id}')">×</button>
                </div>
                <input type="text" class="tag-desc-input" value="${escapeHtml(tag.description)}" oninput="updateTagDescription('${tag.id}', this.value)">
                `;
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('input') && !e.target.closest('button')) selectTag(tag.id);
                });
                tagsListEl.appendChild(item);
            });
        }

        function renderBlurList() {
            tagsListEl.innerHTML = '';
            if (blurs.length === 0) {
                tagsListEl.innerHTML = '<div class="empty-state">Draw an area to blur. Drag corners to adjust.</div>';
                return;
            }
            blurs.forEach(b => {
                const item = document.createElement('div');
                item.className = 'tag-item'; // Reuse styles
                item.id = `blur-item-${b.id}`;
                item.innerHTML = `
                 <div class="tag-header">
                    <span class="tag-coords">Blur Region</span>
                    <button class="delete-btn" onclick="deleteBlur('${b.id}')">×</button>
                </div>
                <input type="text" class="tag-desc-input" placeholder="Watermark (Optional)" value="${escapeHtml(b.text)}" oninput="updateBlurText('${b.id}', this.value)">
                `;
                item.addEventListener('click', (e) => {
                    if (!e.target.closest('input') && !e.target.closest('button')) selectBlur(b.id);
                });
                tagsListEl.appendChild(item);
            });
        }

        function updateTagDescription(id, value) {
            const tag = tags.find(t => t.id === id);
            if (tag) {
                tag.description = value;
                const box = overlay.querySelector(`[data-id="${id}"]`);
                if (box) addLabel(box, value);
            }
        }

        function updateBlurText(id, value) {
            const b = blurs.find(x => x.id === id);
            if (b) b.text = value;
        }

        // --- Actions ---

        function saveTags() {
            const btn = document.getElementById('save-btn');
            const originalText = btn.innerText;
            btn.innerText = 'Saving...';

            fetch('/api/save_tags', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ image_name: "{{ image_name }}", tags: tags })
            })
                .then(res => res.json())
                .then(data => {
                    if (data.status === 'success') {
                        btn.innerText = 'Saved!';
                        setTimeout(() => btn.innerText = originalText, 2000);
                    } else {
                        alert('Error saving tags');
                        btn.innerText = originalText;
                    }
                })
                .catch(err => {
                    console.error(err);
                    alert('Error saving tags');
                    btn.innerText = originalText;
                });
        }

        function burnBlurs() {
            const btn = document.getElementById('burn-btn');
            const originalText = btn.innerText;
            btn.innerText = 'Burning...';

            fetch('/api/apply_blurs', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ image_name: "{{ image_name }}", blurs: blurs })
            })
                .then(res => res.json())
                .then(data => {
                    if (data.status === 'success') {
                        btn.innerText = 'Done!';
                        // Reload to see changes
                        location.reload();
                    } else {
                        alert('Error: ' + data.error);
                        btn.innerText = originalText;
                    }
                })
                .catch(err => {
                    console.error(err);
                    alert('Error connecting to server');
                    btn.innerText = originalText;
                });
        }

        function deleteTag(id) {
            tags = tags.filter(t => t.id !== id);
            const box = overlay.querySelector(`[data-id="${id}"]`);
            if (box) box.remove();
            renderTagsList();
        }

        function deleteBlur(id) {
            blurs = blurs.filter(b => b.id !== id);
            renderBlurs();
            renderBlurList();
        }

        window.deleteTag = deleteTag;
        window.deleteBlur = deleteBlur;
        window.updateTagDescription = updateTagDescription;
        window.updateBlurText = updateBlurText;

        function escapeHtml(text) {
            const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' };
            return text.replace(/[&<>"']/g, function (m) { return map[m]; });
        }

        // Initialize
        window.onload = function () {
            if (tags.length > 0) {
                tags.forEach(tag => {
                    const box = document.createElement('div');
                    box.classList.add('hotspot-box');
                    box.dataset.id = tag.id;
                    box.style.left = tag.x + '%';
                    box.style.top = tag.y + '%';
                    box.style.width = tag.w + '%';
                    box.style.height = tag.h + '%';
                    overlay.appendChild(box);
                    addHandles(box);
                    addLabel(box, tag.description);
                });
                renderTagsList();
            }
            // Setup SVG attrs
            blurOverlay.setAttribute('viewBox', '0 0 100 100');
            blurOverlay.setAttribute('preserveAspectRatio', 'none');
        }

    </script>

</body>

</html>